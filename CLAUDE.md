# CLAUDE.md

Monorepo of MCP server implementations wrapping cybersecurity tools. npm workspaces — `packages/mcp-shared/` must be built first. `servers/<tool>-mcp/` for each tool, `test-e2e/` and `test-integration/` for tests.

## Commands

```bash
npm install                                    # Install all workspace deps
npm run build:shared                           # Build mcp-shared (always first)
npm run build:helpers                          # Build test-helpers
npm -w nmap-mcp run build                      # Build single server
npm -w nmap-mcp test                           # Test single server
npm test                                       # All tests (builds shared libs first)
npm run test:e2e                               # E2E tests (needs Docker running)
npm run test:e2e:smoke                         # E2E healthcheck only
docker compose build                           # Build all Docker images
docker compose up gateway nmap httpx nuclei    # Start gateway + specific tools
docker compose --profile e2e up -d             # Start all + E2E test targets
./scripts/generate-http-config.sh              # Generate gateway-aware mcp-config.json
```

## Server Pattern

Every `src/index.ts` follows this exact sequence:

1. Parse CLI args with `getToolArgs(usage, minArgs?)` — strips `--transport`/`--port` automatically
2. Create `McpServer` instance
3. Register tools named `do-<tool>` with Zod schemas including `...TIMEOUT_SCHEMA`
4. Tool callbacks accept `(args, extra)` — destructure `timeoutSeconds` from args
5. Call `secureSpawn(binary, toolArgs, buildSpawnOptions(extra, { timeoutSeconds }))` to run the tool
6. Return via `formatToolResult(result, { toolName, includeStderr?, stripAnsi? })`
7. Call `await startServer(server)` for transport
8. Log `console.error("<tool> MCP Server running")` after startup

API-based tools (crtsh, http-headers-security, mobsf) use HTTP/axios instead of `secureSpawn` but still pass `extra.signal` and timeout.

All imports from `mcp-shared`: `{ secureSpawn, startServer, getToolArgs, formatToolResult, TIMEOUT_SCHEMA, buildSpawnOptions, sanitizePath, removeAnsiCodes, getEnvOrArg }`

## Conventions

- **Directories:** `servers/<tool>-mcp/` — no exceptions
- **Tool naming:** `do-<tool>` (e.g., `do-nmap`, `do-httpx`, `do-nuclei`)
- **Core deps:** `@modelcontextprotocol/sdk` ^1.17.2, `zod`, `"mcp-shared": "*"` (workspace)
- **TypeScript:** ES2022, Node16, strict — extend `../../tsconfig.base.json`
- **Timeout:** Every tool schema includes `...TIMEOUT_SCHEMA` (default 5 min)
- **Cancellation:** Pass `extra.signal` via `buildSpawnOptions()` — kills process on client disconnect
- **Error handling:** `formatToolResult()` throws on nonzero exitCode with stderr details
- **Logging:** `console.error` only — stdout is reserved for MCP protocol
- **ANSI stripping:** `removeAnsiCodes()` from mcp-shared — only needed for Python tools
- **Path safety:** `sanitizePath()` from mcp-shared for user-supplied file paths
- **Credentials:** `getEnvOrArg()` from mcp-shared — prefers env vars over CLI args
- **Environment:** Auto-loads `.env` via mcp-shared's `loadenv.ts`. Set `MCP_ENV_FILE` for explicit path.
- **Docker build order:** Build `mcp-shared-builder:latest` first — `./scripts/docker-build.sh` handles this
- **Docker retry loops:** `for i in 1 2 3 4 5; do ... && break || sleep 15; done` is intentional for CI/CD resilience
- **E2E targets:** Import `TARGETS`/`WORDLISTS` from `test-e2e/src/helpers/targets.ts` — overridable via `E2E_TARGET_*` env vars

## Don'ts

- Don't use `node-pty` — removed everywhere, Go tools suppress ANSI in pipe mode
- Don't edit `mcp-config.json` manually — auto-generated by `build.sh` / `start.sh` via `jq`
- Don't use `process.argv.slice(2)` — use `getToolArgs()` which strips framework flags
- Don't use `stdout` for logging — reserved for MCP protocol JSON-RPC
- Don't skip `TIMEOUT_SCHEMA` in tool schemas — every tool needs client-configurable timeout
- Don't hardcode domains/IPs/URLs in E2E tests — use `TARGETS` constants
- Don't replace Docker retry loops with single-attempt installs
- Don't import server modules directly in tests — has side effects from `getToolArgs()`/`startServer()`

## Adding a New Server

1. `npm run build:shared` (if not already built)
2. Create `servers/<tool>-mcp/` with `tsconfig.json` extending `../../tsconfig.base.json`
3. Create `package.json` with core deps + `"test-helpers": "*"` in devDependencies + `"test": "node --test 'build/__tests__/*.test.js'"` in scripts
4. Implement `src/index.ts` following the Server Pattern above
5. Create `build.sh`: set `BIN_ARGS`, `SERVICE_PATH`, then `source "$SERVICE_PATH/../../scripts/build-common.sh"`
6. Add tests in `src/__tests__/<tool>.test.ts` — mirror tool registration with mock spawn (copy from existing server)
7. Create `README.md` with usage, setup, and 3-5 example prompts showing conversational invocation
8. Add entry to root `README.md` tools table
9. Add Docker infrastructure: entry in `docker-compose.yml`, service in `docker/services.json`, and ensure the tool's Dockerfile category covers it (see `docker/Dockerfile.*`)
10. `npm install` at repo root to link workspace, then `npm -w <tool>-mcp run build && npm -w <tool>-mcp test`

## Testing

All server tests use mock spawn — no real security tools needed. Tests mirror the tool registration from `src/index.ts` but inject `createMockSpawn()` instead of `secureSpawn`.

Key exports from `test-helpers`: `createTestServer`, `createMockSpawn`, `assertToolExists`, `assertToolCallSucceeds`, `assertToolCallFails`, `getResultText`

Four tiers: **Unit** (mcp-shared modules) → **Server** (mock spawn + InMemoryTransport) → **Integration** (real spawn + echo) → **E2E** (Docker + HTTP gateway)

```bash
npm test                                       # All unit + server + integration
npm -w <tool>-mcp run build && npm -w <tool>-mcp test   # Single server
npm run test:e2e                               # E2E (requires docker compose --profile e2e up -d)
```

## Requirements

Use context7 for documentation
